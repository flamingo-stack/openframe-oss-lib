<!-- source-hash: 7b6f1eadf9dbb4811ac24b45741cf71e -->
A technology-agnostic base interface for user repository operations that supports both reactive and blocking implementations through generic type parameters.

## Key Components

- **Generic Type Parameters**:
  - `T` - Return type wrapper (Optional for blocking, Mono for reactive)
  - `B` - Boolean return type (boolean for blocking, Mono<Boolean> for reactive)
  - `ID` - Identifier type (String)

- **Core Methods**:
  - `findByEmail(String email)` - Retrieves user by email address
  - `existsByEmail(String email)` - Checks user existence by email
  - `existsByEmailAndStatus(String email, UserStatus status)` - Checks user existence with status filter

## Usage Example

```java
// Blocking implementation
public class BlockingUserRepository implements BaseUserRepository<Optional<User>, Boolean, String> {
    @Override
    public Optional<User> findByEmail(String email) {
        // Implementation using JPA or other blocking technology
        return userJpaRepository.findByEmail(email);
    }
    
    @Override
    public Boolean existsByEmail(String email) {
        return userJpaRepository.existsByEmail(email);
    }
}

// Reactive implementation
public class ReactiveUserRepository implements BaseUserRepository<Mono<User>, Mono<Boolean>, String> {
    @Override
    public Mono<User> findByEmail(String email) {
        // Implementation using reactive MongoDB or R2DBC
        return mongoTemplate.findOne(Query.query(where("email").is(email)), User.class);
    }
    
    @Override
    public Mono<Boolean> existsByEmailAndStatus(String email, UserStatus status) {
        return mongoTemplate.exists(
            Query.query(where("email").is(email).and("status").is(status)), 
            User.class
        );
    }
}
```

This design enables polymorphic usage across different persistence technologies while maintaining type safety and clear contracts for user data access operations.