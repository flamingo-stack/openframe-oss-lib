<!-- source-hash: 55dd98213c3fd8241e65a10445a4fb5b -->
A comprehensive hook that manages cursor-based pagination state, URL synchronization, debounced search, and filter management to eliminate repetitive boilerplate code from paginated components.

## Key Components

**Main Hook:**
- `useCursorPaginationState(options)` - Primary hook that manages all pagination state

**Key Options:**
- `paramPrefix` - URL parameter prefix for multi-tab scenarios
- `filterSchema` - Schema for additional filter parameters
- `onInitialLoad` - Callback for initial page load
- `onSearchChange` - Callback when search changes (debounced)
- `onFiltersChange` - Callback when filters change

**Return Values:**
- `searchInput/setSearchInput` - Local search input with debouncing
- `hasLoadedBeyondFirst` - Tracks if user has paginated past first page
- `handleNextPage/handleResetToFirstPage` - Pagination control handlers
- `handleFilterChange` - Filter update handler
- URL parameter access (`params`, `setParam`, `setParams`)

## Usage Example

```typescript
const {
  searchInput,
  setSearchInput,
  hasLoadedBeyondFirst,
  handleNextPage,
  handleResetToFirstPage
} = useCursorPaginationState({
  paramPrefix: 'dialogs',
  debounceMs: 500,
  filterSchema: {
    status: { type: 'array', default: [] },
    category: { type: 'string', default: '' }
  },
  onInitialLoad: (search, cursor) => {
    return fetchDialogs({ search, cursor, reset: false })
  },
  onSearchChange: (search) => {
    return fetchDialogs({ search, reset: true })
  },
  onFiltersChange: (filters) => {
    return fetchDialogs({ filters, reset: true })
  }
})
```