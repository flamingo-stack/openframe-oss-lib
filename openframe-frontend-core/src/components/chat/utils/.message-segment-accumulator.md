<!-- source-hash: cff141bf1c94cc3e98e3c44f584a3383 -->
Manages accumulation of message segments during real-time streaming or historical message processing, handling text appending, tool execution state transitions, and approval request tracking.

## Key Components

- **MessageSegmentAccumulator**: Main class for accumulating and managing different types of message segments
- **AccumulatorCallbacks**: Interface for approval action callbacks (onApprove, onReject)
- **initializeWithState()**: Restores accumulator state from existing segments and pending operations
- **appendText()**: Efficiently appends text by merging with the last text segment
- **addToolExecution()**: Manages tool execution lifecycle (EXECUTING_TOOL â†’ EXECUTED_TOOL transitions)
- **trackApprovalRequest()** / **processApprovalResult()**: Handles approval request lifecycle
- **getState()** / **reset()**: State management for serialization and cleanup
- **createMessageSegmentAccumulator()**: Factory function for creating new instances

## Usage Example

```typescript
import { createMessageSegmentAccumulator } from './message-segment-accumulator'

// Create accumulator with approval callbacks
const accumulator = createMessageSegmentAccumulator({
  onApprove: async (requestId) => console.log(`Approved: ${requestId}`),
  onReject: async (requestId) => console.log(`Rejected: ${requestId}`)
})

// Build message incrementally
accumulator.appendText("Processing your request...")
accumulator.addToolExecution({
  type: 'tool_execution',
  data: { type: 'EXECUTING_TOOL', integratedToolType: 'system', toolFunction: 'listFiles' }
})

// Get current segments
const segments = accumulator.getSegments()

// Save state for persistence
const state = accumulator.getState()

// Restore from saved state later
accumulator.initializeWithState({
  existingSegments: state.segments,
  pendingApprovals: state.pendingApprovals
})
```