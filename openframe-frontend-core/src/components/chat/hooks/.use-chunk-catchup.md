<!-- source-hash: 9776b4038d8695da9d5a33a4dc05d48b -->
A React hook for managing chunk synchronization during real-time chat dialog loading, handling buffering, deduplication, and proper ordering of message chunks from both NATS streams and API catchup.

## Key Components

- **useChunkCatchup**: Main hook that orchestrates chunk catchup during dialog loading
- **processChunk**: Processes individual chunks with optional buffering during catchup
- **catchUpChunks**: Fetches historical chunks from API and merges with buffered realtime chunks
- **flushBufferedRealtimeChunks**: Processes buffered chunks after catchup completion
- **resetChunkTracking**: Resets all internal state for new dialog sessions
- **startInitialBuffering**: Enables buffering mode for initial catchup phase

## Usage Example

```typescript
import { useChunkCatchup } from './use-chunk-catchup'
import { CHAT_TYPE } from '../types'

function ChatDialog({ dialogId, fetchChunks }) {
  const {
    catchUpChunks,
    processChunk,
    resetChunkTracking,
    startInitialBuffering,
    isBufferingActive
  } = useChunkCatchup({
    dialogId,
    onChunkReceived: (chunk, messageType) => {
      console.log('Processing chunk:', chunk)
      // Handle the chunk in your UI
    },
    chatTypes: [CHAT_TYPE.CLIENT, CHAT_TYPE.ADMIN],
    fetchChunks: async (dialogId, chatType, fromSeqId) => {
      return await api.fetchDialogChunks(dialogId, chatType, fromSeqId)
    }
  })

  // Start catchup when dialog loads
  useEffect(() => {
    if (dialogId) {
      startInitialBuffering()
      catchUpChunks()
    }
  }, [dialogId])

  // Process realtime chunks from NATS
  const handleNatsChunk = useCallback((chunk, messageType) => {
    processChunk(chunk, messageType)
  }, [processChunk])

  return <div>Chat content...</div>
}
```

The hook handles complex scenarios like preventing duplicate chunks, maintaining sequence order, buffering realtime chunks during catchup, and finding complete message boundaries to ensure proper synchronization.