<!-- source-hash: 06dd2157d7361654ed746ecea4509488 -->
A Jakarta Bean Validation constraint validator that validates email addresses using configurable regex patterns. This validator implements the `ConstraintValidator` interface to provide runtime validation for the `@ValidEmail` annotation.

## Key Components

- **ValidEmailValidator** - Main validator class implementing `ConstraintValidator<ValidEmail, String>`
- **initialize()** - Compiles the regex pattern from the annotation configuration
- **isValid()** - Performs the actual email validation using pattern matching

## Usage Example

```java
// First, define the @ValidEmail annotation (typically in a separate file)
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = ValidEmailValidator.class)
public @interface ValidEmail {
    String message() default "Invalid email format";
    String regex() default "^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

// Use in your entity or DTO
public class User {
    @ValidEmail
    private String email;
    
    @ValidEmail(regex = "^[a-zA-Z0-9._%+-]+@company\\.com$", 
               message = "Must be a company email")
    private String workEmail;
}

// Validation occurs automatically during Bean Validation
Validator validator = Validation.buildDefaultValidatorFactory().getValidator();
Set<ConstraintViolation<User>> violations = validator.validate(user);
```

The validator returns `false` for null values and uses the configurable regex pattern to validate email format, making it flexible for different email validation requirements.