<!-- source-hash: 7f6918247c20dc22c86b3995c6b42c86 -->
A Spring reactive repository that provides thread-safe rate limiting functionality using Redis as the backend storage. This component implements atomic counter operations with time window tracking for web applications.

## Key Components

**Main Class:**
- `ReactiveRateLimitRepository` - Primary repository handling rate limit operations

**Core Methods:**
- `checkAndIncrement()` - Atomically checks rate limit and increments counter
- `getStatus()` - Retrieves current rate limit status without incrementing
- `getTimestamp()` - Extracts timestamp data from Redis hash fields
- `buildRedisKey()` - Constructs Redis keys with proper prefixing

**Result Model:**
- `RateLimitResult` - Immutable data class containing rate limit state information

## Usage Example

```java
@Service
public class ApiRateLimitService {
    
    private final ReactiveRateLimitRepository rateLimitRepository;
    
    public Mono<Boolean> isRequestAllowed(String userId, String endpoint) {
        String window = "hourly";
        String timestamp = String.valueOf(System.currentTimeMillis() / 3600000); // hourly window
        long limit = 100; // 100 requests per hour
        Duration ttl = Duration.ofHours(1);
        
        return rateLimitRepository
            .checkAndIncrement(userId + ":" + endpoint, window, timestamp, limit, ttl)
            .map(ReactiveRateLimitRepository.RateLimitResult::isAllowed)
            .doOnNext(allowed -> {
                if (!allowed) {
                    log.warn("Rate limit exceeded for user: {}", userId);
                }
            });
    }
    
    public Mono<RateLimitResult> getRateLimitStatus(String userId) {
        String window = "daily";
        String timestamp = String.valueOf(System.currentTimeMillis() / 86400000);
        
        return rateLimitRepository.getStatus(userId, window, timestamp, 1000);
    }
}
```