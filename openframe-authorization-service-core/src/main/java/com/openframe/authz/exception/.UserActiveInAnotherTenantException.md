<!-- source-hash: d0044fcd975f423aa895b050ba9ed889 -->
A custom runtime exception thrown when attempting to perform tenant-related operations on a user who is already active in a different tenant, ensuring proper tenant isolation in multi-tenant applications.

## Key Components

- **UserActiveInAnotherTenantException**: A runtime exception that extends `RuntimeException` to indicate tenant conflicts
- **Constructor**: Takes a user email parameter and generates a descriptive error message

## Usage Example

```java
// Service layer validation
public void assignUserToTenant(String email, String tenantId) {
    User user = userRepository.findByEmail(email);
    
    if (user.isActiveInTenant() && !user.getTenantId().equals(tenantId)) {
        throw new UserActiveInAnotherTenantException(email);
    }
    
    // Proceed with tenant assignment
    user.assignToTenant(tenantId);
}

// Exception handling
try {
    tenantService.assignUserToTenant("user@example.com", "tenant-123");
} catch (UserActiveInAnotherTenantException e) {
    logger.error("Tenant conflict detected: {}", e.getMessage());
    // Handle tenant switching logic or deny request
}
```

This exception helps maintain data integrity and security boundaries in multi-tenant systems by preventing users from being simultaneously active across multiple tenants.